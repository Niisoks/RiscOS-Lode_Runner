#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "main.h"

char map[HEIGHT][WIDTH + 1] = {
    "####################",
    "#         H        #",
    "#  H###H###H#####  #",
    "#  H#  H  #H       #",
    "#  H# #H# #H  ######",
    "#  H# #H# #H    G  #",
    "# #H# #H# #####H#  #",
    "#  H   H#  G   H   #",
    "#  H   H     H######",
    "#  H   H     H#    #",
    "#  H   H           #",
    "#  H   H    ##H    #",
    "#  H   H      H    #",
    "####################",
};

typedef enum {
    NEUTRAL,
    LEFT,
    RIGHT,
    UP,
    DOWN
} Direction;

typedef struct {
    int tileX, tileY;      
    float visualX, visualY; 
    float targetX, targetY; 
    int isMoving;          
    Direction moveDir;     
} Entity;

typedef struct {
    Entity player;          
    Entity enemies[MAX_ENEMIES]; 
    int enemyCount;         
    int goldTotal;          
    int goldCollected;      
    int frame;              
    int gameOver;           
    float pixelSpeed;       
    int enemyUpdateCooldown; 
} GameState;

GameState gameState;  

typedef union {
    int numbers[14];
    struct {
        int modeFlags, scrRCol, scrBRow, nColour,
            xEigFactor, yEigFactor, lineLength, screenSize,
            yShiftSize, log2bpp, log2bpc, xWindLimit,
            yWindLimit, minScreenBanks;
    } info;
} ModeInfo;

ModeInfo modeInfo;

void initialiseTimer() {
    timer = 0;
    timerCallback = NULL;
    timerWorkspace = NULL;
}

void setTimer(int cs, void (*callback)(void*), void *ws) {
    timer = os_read_monotonic_time() + cs;
    timerCallback = callback;
    timerWorkspace = ws;   
}

void updateTimer() {
    if (timer > 0) {      
        os_t time = os_read_monotonic_time();
        if (time >= timer) {
            timer = 0;
            timerCallback(timerWorkspace);
        }
    }
}

void updateModeInfo() {                                      
    int i;
    for (i = 0; i < 15; i++) {
        modeInfo.numbers[i] = i;
    }
    modeInfo.numbers[14] = -1;
    xos_read_vdu_variables((os_vdu_var_list*)modeInfo.numbers, modeInfo.numbers);
}

osspriteop_area* loadSpriteFile(const char *filename) {                                                       
    int size;
    bits type;
    fileswitch_object_type objType;
    os_error *e;

    xosfile_read_stamped_no_path(filename, &objType, NULL, NULL, &size, NULL, &type);
    size += sizeof(int);
    osspriteop_area *area = malloc(size);
    area->size = size;
    area->first = 16;

    xosspriteop_load_sprite_file(osspriteop_USER_AREA, area, filename);

    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"runner1", &playerSprite1);
    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"runner2", &playerSprite2);
    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"enemy1", &enemySprite1);
    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"enemy2", &enemySprite2);
    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"wall", &wallSprite);
    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"ladder", &ladderSprite);
    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"gold", &goldSprite);

    factors.xmul = (1<<(modeInfo.info.xEigFactor-1)) * GAME_SIZE;
    factors.ymul = 1<<(modeInfo.info.yEigFactor) * GAME_SIZE;
    factors.xdiv = 1;
    factors.ydiv = 2;         

    return area;
}

wimp_window* createWindow() {
    wimp_window* window = (wimp_window*)malloc(sizeof(wimp_window));

    window->visible.x0 = 0;
    window->visible.y0 = 0;
    window->visible.x1 = WIDTH * TILE_SIZE;
    window->visible.y1 = HEIGHT * TILE_SIZE;
    window->xscroll = 0;
    window->yscroll = 0;
    window->next = wimp_TOP;
    window->flags = wimp_WINDOW_MOVEABLE  
                  | wimp_WINDOW_BACK_ICON 
                  | wimp_WINDOW_CLOSE_ICON 
                  | wimp_WINDOW_TITLE_ICON 
                  | wimp_WINDOW_TOGGLE_ICON 
                  | wimp_WINDOW_SIZE_ICON 
                  | wimp_WINDOW_NEW_FORMAT
                  | wimp_WINDOW_HAS_FOCUS
                  | wimp_WINDOW_HOT_KEYS
                  | wimp_WINDOW_SCROLL;
    window->title_fg = wimp_COLOUR_BLACK;
    window->title_bg = wimp_COLOUR_LIGHT_GREY;
    window->work_fg = wimp_COLOUR_WHITE;
    window->work_bg = wimp_COLOUR_BLACK; 
    window->scroll_outer = wimp_COLOUR_MID_LIGHT_GREY;
    window->scroll_inner = wimp_COLOUR_VERY_LIGHT_GREY;
    window->highlight_bg = wimp_COLOUR_CREAM;

    window->extent.x0 = 0;
    window->extent.y0 = -HEIGHT * TILE_SIZE * 2;
    window->extent.x1 = WIDTH * TILE_SIZE;
    window->extent.y1 = HEIGHT * TILE_SIZE * 2;

    window->title_flags = wimp_ICON_TEXT | wimp_ICON_HCENTRED | wimp_ICON_VCENTRED;
    window->work_flags = wimp_BUTTON_WRITABLE << wimp_ICON_BUTTON_TYPE_SHIFT;
    window->sprite_area = 0;
    window->xmin = 0;
    window->ymin = 0;
    window->icon_count = 0;

    strncpy(window->title_data.text, "Lode Runner", 12);

    return window;
}

wimp_block* createWimpBlock(wimp_window* window) {
    wimp_block* block = (wimp_block*)malloc(sizeof(wimp_block));
    block->open.w = wimp_create_window(window);
    block->open.visible = window->visible;
    block->open.xscroll = window->xscroll;
    block->open.yscroll = window->yscroll;
    block->open.next = window->next;
    gameWindow = block->open.w;
    return block;
}

void redrawWindow(wimp_block *block) {
    int more;
    xwimp_redraw_window(&block->redraw, &more);
    render(&block->redraw, more);
}

void render(wimp_draw *draw, osbool more) {
    int x, y, i;
    GameState *state = &gameState;

    while (more) {

        int baseX = draw->box.x0 - draw->xscroll;
        int baseY = draw->box.y1 - draw->yscroll;

        for (y = 0; y < HEIGHT; y++) {
            for (x = 0; x < WIDTH; x++) {
                int screenX = baseX + (x * TILE_SIZE);
                int screenY = baseY - (y * TILE_SIZE);
                osspriteop_header *sprite = NULL;

                switch (map[y][x]) {
                    case '#': sprite = wallSprite; break;
                    case 'H': sprite = ladderSprite; break;
                    case 'G': sprite = goldSprite; break;
                }

                if (sprite != NULL) {
                    xosspriteop_put_sprite_scaled(
                        osspriteop_PTR, spriteArea, (osspriteop_id)sprite,
                        screenX, screenY, 
                        os_ACTION_OVERWRITE | osspriteop_GIVEN_WIDE_ENTRIES | osspriteop_USE_MASK,
                        &factors, transTab
                    );
                }
            }
        }

        int playerScreenX = baseX + (int)(state->player.visualX * TILE_SIZE);
        int playerScreenY = baseY - (int)(state->player.visualY * TILE_SIZE);

        xosspriteop_put_sprite_scaled(
            osspriteop_PTR, spriteArea, (osspriteop_id)playerSprite1,
            playerScreenX, playerScreenY,
            os_ACTION_OVERWRITE | osspriteop_GIVEN_WIDE_ENTRIES | osspriteop_USE_MASK,
            &factors, transTab
        );

        for (i = 0; i < state->enemyCount; i++) {
            Entity *enemy = &state->enemies[i];
            int enemyScreenX = baseX + (int)(enemy->visualX * TILE_SIZE);
            int enemyScreenY = baseY - (int)(enemy->visualY * TILE_SIZE);

            xosspriteop_put_sprite_scaled(
                osspriteop_PTR, spriteArea, (osspriteop_id)enemySprite1,
                enemyScreenX, enemyScreenY,
                os_ACTION_OVERWRITE | osspriteop_GIVEN_WIDE_ENTRIES | osspriteop_USE_MASK,
                &factors, transTab
            );
        }

        xwimp_get_rectangle(draw, &more);
    }
}

void updateWindow(wimp_w window) {
    wimp_draw draw;
    int more;

    draw.w = window;
    draw.box.x0 = 0;
    draw.box.y0 = -HEIGHT * TILE_SIZE * 2;
    draw.box.x1 = WIDTH * TILE_SIZE; 
    draw.box.y1 = HEIGHT * TILE_SIZE * 2;

    xwimp_update_window(&draw, &more);
    render(&draw, more);
}

void countGold(GameState *state) {
    int x, y;

    state->goldTotal = 0;
    for (y = 0; y < HEIGHT; y++) {
        for (x = 0; x < WIDTH; x++) {
            if (map[y][x] == 'G') {
                state->goldTotal++;
            }
        }
    }
}

void initialiseGame(GameState *state) {

    state->player.tileX = 5;
    state->player.tileY = 1;
    state->player.visualX = 5.0f;
    state->player.visualY = 1.0f;
    state->player.targetX = state->player.visualX;
    state->player.targetY = state->player.visualY;
    state->player.isMoving = 0;
    state->player.moveDir = NEUTRAL;

    state->enemyCount = 1;
    state->enemies[0].tileX = 15;
    state->enemies[0].tileY = 7;
    state->enemies[0].visualX = 15.0f;
    state->enemies[0].visualY = 7.0f;
    state->enemies[0].targetX = state->enemies[0].visualX;
    state->enemies[0].targetY = state->enemies[0].visualY;
    state->enemies[0].isMoving = 0;
    state->enemies[0].moveDir = NEUTRAL;

    state->goldCollected = 0;
    countGold(state);
    state->frame = 0;
    state->gameOver = 0;
    state->pixelSpeed = 0.15f;
    state->enemyUpdateCooldown = 0;
}

osbool update(wimp_event_no event, wimp_block* block) {
    switch(event) {
        case wimp_KEY_PRESSED:

            break;
        case wimp_REDRAW_WINDOW_REQUEST:
            redrawWindow(block);
            break;
        case wimp_OPEN_WINDOW_REQUEST:
            wimp_open_window(&block->open);
            break;
        case wimp_CLOSE_WINDOW_REQUEST:
            wimp_close_window(block->close.w);
            return TRUE;
        case wimp_USER_MESSAGE:
            break;
        case wimp_USER_MESSAGE_RECORDED:
            if(block->message.action == message_QUIT) {
                return TRUE;
            }
            break;
    }

    return FALSE;
}

int main() {

   wimp_initialise(wimp_VERSION_RO3, "Lode Runner", NULL, NULL);

   updateModeInfo();
   spriteArea = loadSpriteFile("<LodeRunner$Dir>.sprites");
   window = createWindow();
   block = createWimpBlock(window);

   initialiseTimer();
   initialiseGame(&gameState);

   xwimp_open_window(&block->open);

   osbool quit = FALSE;
   while(!quit) {
       wimp_event_no event = wimp_poll(0, block, NULL);

       if (event == wimp_NULL_REASON_CODE) {
           updateTimer();
       } else {
           quit = update(event, block);
       }
   }

   free(block);
   free(window);
   wimp_close_down(0);

   return 0;
}