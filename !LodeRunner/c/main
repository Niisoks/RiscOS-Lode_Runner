#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "main.h"

char map[HEIGHT][WIDTH + 1] = {
    "####################",
    "#         H        #",
    "#  H###H###H#####  #",
    "#  H#  H  #H       #",
    "#  H# #H# #H  ######",
    "#  H# #H# #H    G  #",
    "# #H# #H# #####H#  #",
    "#  H   H#  G   H   #",
    "#  H   H     H######",
    "#  H   H     H#    #",
    "#  H   H           #",
    "#  H   H    ##H    #",
    "#  H   H      H    #",
    "####################",
};

typedef enum {
    NEUTRAL,
    LEFT,
    RIGHT,
    UP,
    DOWN
} Direction;

typedef struct {
    int tileX, tileY;      
    float visualX, visualY; 
    float targetX, targetY; 
    int isMoving;          
    Direction moveDir;     
} Entity;

typedef struct {
    Entity player;          
    Entity enemies[MAX_ENEMIES]; 
    int enemyCount;         
    int goldTotal;          
    int goldCollected;      
    int frame;              
    int gameOver;           
    float pixelSpeed;       
    int enemyUpdateCooldown; 
} GameState;

GameState gameState;  

int playerIsFalling = 0;

int keyState[4] = {0};      
int keyPressedThisFrame[4] = {0};

typedef union {
    int numbers[14];
    struct {
        int modeFlags, scrRCol, scrBRow, nColour,
            xEigFactor, yEigFactor, lineLength, screenSize,
            yShiftSize, log2bpp, log2bpc, xWindLimit,
            yWindLimit, minScreenBanks;
    } info;
} ModeInfo;

ModeInfo modeInfo;

void initialiseTimer() {
    timer = 0;
    timerCallback = NULL;
    timerWorkspace = NULL;
}

void setTimer(int cs, void (*callback)(void*), void *ws) {
    timer = os_read_monotonic_time() + cs;
    timerCallback = callback;
    timerWorkspace = ws;   
}

void updateTimer() {
    if (timer > 0) {      
        os_t time = os_read_monotonic_time();
        if (time >= timer) {
            timer = 0;
            timerCallback(timerWorkspace);
        }
    }
}

void updateModeInfo() {                                      
    int i;
    for (i = 0; i < 15; i++) {
        modeInfo.numbers[i] = i;
    }
    modeInfo.numbers[14] = -1;
    xos_read_vdu_variables((os_vdu_var_list*)modeInfo.numbers, modeInfo.numbers);
}

osspriteop_area* loadSpriteFile(const char *filename) {                                                       
    int size;
    bits type;
    fileswitch_object_type objType;
    os_error *e;

    xosfile_read_stamped_no_path(filename, &objType, NULL, NULL, &size, NULL, &type);
    size += sizeof(int);
    osspriteop_area *area = malloc(size);
    area->size = size;
    area->first = 16;

    xosspriteop_load_sprite_file(osspriteop_USER_AREA, area, filename);

    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"runner1", &playerSprite1);
    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"runner2", &playerSprite2);
    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"enemy1", &enemySprite1);
    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"enemy2", &enemySprite2);
    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"wall", &wallSprite);
    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"ladder", &ladderSprite);
    e = xosspriteop_select_sprite(osspriteop_USER_AREA, area, (osspriteop_id)"gold", &goldSprite);

    factors.xmul = (1<<(modeInfo.info.xEigFactor-1)) * GAME_SIZE;
    factors.ymul = 1<<(modeInfo.info.yEigFactor) * GAME_SIZE;
    factors.xdiv = 1;
    factors.ydiv = 2;         

    return area;
}

wimp_window* createWindow() {
    wimp_window* window = (wimp_window*)malloc(sizeof(wimp_window));

    window->visible.x0 = 0;
    window->visible.y0 = 0;
    window->visible.x1 = WIDTH * TILE_SIZE;
    window->visible.y1 = HEIGHT * TILE_SIZE;
    window->xscroll = 0;
    window->yscroll = 0;
    window->next = wimp_TOP;
    window->flags = wimp_WINDOW_MOVEABLE  
                  | wimp_WINDOW_BACK_ICON 
                  | wimp_WINDOW_CLOSE_ICON 
                  | wimp_WINDOW_TITLE_ICON 
                  | wimp_WINDOW_TOGGLE_ICON 
                  | wimp_WINDOW_SIZE_ICON 
                  | wimp_WINDOW_NEW_FORMAT
                  | wimp_WINDOW_HAS_FOCUS
                  | wimp_WINDOW_HOT_KEYS
                  | wimp_WINDOW_SCROLL;
    window->title_fg = wimp_COLOUR_BLACK;
    window->title_bg = wimp_COLOUR_LIGHT_GREY;
    window->work_fg = wimp_COLOUR_WHITE;
    window->work_bg = wimp_COLOUR_BLACK; 
    window->scroll_outer = wimp_COLOUR_MID_LIGHT_GREY;
    window->scroll_inner = wimp_COLOUR_VERY_LIGHT_GREY;
    window->highlight_bg = wimp_COLOUR_CREAM;

    window->extent.x0 = 0;
    window->extent.y0 = -HEIGHT * TILE_SIZE * 2;
    window->extent.x1 = WIDTH * TILE_SIZE;
    window->extent.y1 = HEIGHT * TILE_SIZE * 2;

    window->title_flags = wimp_ICON_TEXT | wimp_ICON_HCENTRED | wimp_ICON_VCENTRED;
    window->work_flags = wimp_BUTTON_WRITABLE << wimp_ICON_BUTTON_TYPE_SHIFT;
    window->sprite_area = 0;
    window->xmin = 0;
    window->ymin = 0;
    window->icon_count = 0;

    strncpy(window->title_data.text, "Lode Runner", 12);

    return window;
}

wimp_block* createWimpBlock(wimp_window* window) {
    wimp_block* block = (wimp_block*)malloc(sizeof(wimp_block));
    block->open.w = wimp_create_window(window);
    block->open.visible = window->visible;
    block->open.xscroll = window->xscroll;
    block->open.yscroll = window->yscroll;
    block->open.next = window->next;
    gameWindow = block->open.w;
    return block;
}

void redrawWindow(wimp_block *block) {
    int more;
    xwimp_redraw_window(&block->redraw, &more);
    render(&block->redraw, more);
}

void render(wimp_draw *draw, osbool more) {
    int x, y, i;
    GameState *state = &gameState;

    while (more) {

        int baseX = draw->box.x0 - draw->xscroll;
        int baseY = draw->box.y1 - draw->yscroll;

        for (y = 0; y < HEIGHT; y++) {
            for (x = 0; x < WIDTH; x++) {
                int screenX = baseX + (x * TILE_SIZE);
                int screenY = baseY - (y * TILE_SIZE);
                osspriteop_header *sprite = NULL;

                switch (map[y][x]) {
                    case '#': sprite = wallSprite; break;
                    case 'H': sprite = ladderSprite; break;
                    case 'G': sprite = goldSprite; break;
                }

                if (sprite != NULL) {
                    xosspriteop_put_sprite_scaled(
                        osspriteop_PTR, spriteArea, (osspriteop_id)sprite,
                        screenX, screenY, 
                        os_ACTION_OVERWRITE | osspriteop_GIVEN_WIDE_ENTRIES | osspriteop_USE_MASK,
                        &factors, transTab
                    );
                }
            }
        }

        int playerScreenX = baseX + (int)(state->player.visualX * TILE_SIZE);
        int playerScreenY = baseY - (int)(state->player.visualY * TILE_SIZE);

        xosspriteop_put_sprite_scaled(
            osspriteop_PTR, spriteArea, (osspriteop_id)playerSprite1,
            playerScreenX, playerScreenY,
            os_ACTION_OVERWRITE | osspriteop_GIVEN_WIDE_ENTRIES | osspriteop_USE_MASK,
            &factors, transTab
        );

        for (i = 0; i < state->enemyCount; i++) {
            Entity *enemy = &state->enemies[i];
            int enemyScreenX = baseX + (int)(enemy->visualX * TILE_SIZE);
            int enemyScreenY = baseY - (int)(enemy->visualY * TILE_SIZE);

            xosspriteop_put_sprite_scaled(
                osspriteop_PTR, spriteArea, (osspriteop_id)enemySprite1,
                enemyScreenX, enemyScreenY,
                os_ACTION_OVERWRITE | osspriteop_GIVEN_WIDE_ENTRIES | osspriteop_USE_MASK,
                &factors, transTab
            );
        }

        xwimp_get_rectangle(draw, &more);
    }
}

void updateWindow(wimp_w window) {
    wimp_draw draw;
    int more;

    draw.w = window;
    draw.box.x0 = 0;
    draw.box.y0 = -HEIGHT * TILE_SIZE * 2;
    draw.box.x1 = WIDTH * TILE_SIZE; 
    draw.box.y1 = HEIGHT * TILE_SIZE * 2;

    xwimp_update_window(&draw, &more);
    render(&draw, more);
}

void countGold(GameState *state) {
    int x, y;

    state->goldTotal = 0;
    for (y = 0; y < HEIGHT; y++) {
        for (x = 0; x < WIDTH; x++) {
            if (map[y][x] == 'G') {
                state->goldTotal++;
            }
        }
    }
}

int isWalkable(int x, int y) {
    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT)
        return 0;

    char tile = map[y][x];
    return (tile == ' ' || tile == 'G' || tile == 'H');
}

int isClimbable(int x, int y) {
    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT)
        return 0;

    return (map[y][x] == 'H');
}

int isSolid(int x, int y) {
    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT)
        return 0;

    return (map[y][x] == '#' || map[y][x] == 'G');
}

int isLadderTop(int x, int y) {
    return y + 1 < HEIGHT && map[y + 1][x] == 'H' && map[y][x] != 'H' && map[y][x] != '#';
}

int supports(int x, int y) {
    if (y + 1 >= HEIGHT) return 1;  

    return isSolid(x, y + 1) || isLadderTop(x, y) || isClimbable(x, y);
}

void moveEntity(GameState *state, Entity *entity, Direction dir, int isPlayer) {

    if (!entity->isMoving || entity->moveDir != dir) {

        if (isPlayer) {

            if (playerIsFalling && (dir == LEFT || dir == RIGHT)) {
                return;
            }
        }

        int tileX = entity->tileX;
        int tileY = entity->tileY;

        if (dir == LEFT || dir == RIGHT) {

            int nextX = tileX + (dir == LEFT ? -1 : 1);

            if (isWalkable(nextX, tileY)) {
                entity->targetX = (float)nextX;
                entity->targetY = (float)tileY;
                entity->isMoving = 1;
                entity->moveDir = dir;
            }

            else if (isPlayer && isSolid(nextX, tileY)) {
                float partialX;

                if (dir == LEFT) {

                    partialX = (float)tileX - WALL_PADDING;
                } else { 

                    partialX = (float)tileX + WALL_PADDING;
                }

                entity->targetX = partialX;
                entity->targetY = (float)tileY;
                entity->isMoving = 1;
                entity->moveDir = dir;
            }
        } 
        else if (dir == UP) {

            if (isClimbable(tileX, tileY)) {

                if (tileY > 0 && (isClimbable(tileX, tileY-1) || isWalkable(tileX, tileY-1))) {
                    entity->targetX = (float)tileX;
                    entity->targetY = (float)(tileY - 1);
                    entity->isMoving = 1;
                    entity->moveDir = dir;
                }

                else if (isPlayer && tileY > 0 && isSolid(tileX, tileY-1)) {
                    entity->targetX = (float)tileX;
                    entity->targetY = (float)tileY - WALL_PADDING;
                    entity->isMoving = 1;
                    entity->moveDir = dir;
                }
            }
        }
        else if (dir == DOWN) {

            if (isClimbable(tileX, tileY) || 
                (tileY < HEIGHT-1 && isClimbable(tileX, tileY+1) && supports(tileX, tileY))) {

                if (tileY < HEIGHT-1 && 
                    (isClimbable(tileX, tileY+1) || isLadderTop(tileX, tileY))) {
                    entity->targetX = (float)tileX;
                    entity->targetY = (float)(tileY + 1);
                    entity->isMoving = 1;
                    entity->moveDir = dir;
                }

                else if (isPlayer && tileY < HEIGHT-1 && isSolid(tileX, tileY+1)) {
                    entity->targetX = (float)tileX;
                    entity->targetY = (float)tileY + WALL_PADDING;
                    entity->isMoving = 1;
                    entity->moveDir = dir;
                }
            }
        }
    }
}

void updateLogicalPosition(Entity *entity) {
    entity->tileX = (int)round(entity->visualX);
    entity->tileY = (int)round(entity->visualY);
}

void updateMovementAnimation(GameState *state) {

    Entity *player = &state->player;
    if (player->isMoving) {
        float dx = player->targetX - player->visualX;
        float dy = player->targetY - player->visualY;
        float length = sqrt(dx * dx + dy * dy);

        if (length > 0) {
            dx /= length;
            dy /= length;
        }

        player->visualX += dx * state->pixelSpeed;
        player->visualY += dy * state->pixelSpeed;

        float distToTarget = sqrt(
            pow(player->targetX - player->visualX, 2) + 
            pow(player->targetY - player->visualY, 2)
        );

        if (distToTarget < state->pixelSpeed) {
            player->visualX = player->targetX;
            player->visualY = player->targetY;
            player->isMoving = 0;

            if (playerIsFalling && player->moveDir == DOWN) {
                playerIsFalling = 0;
            }
        }

        updateLogicalPosition(player);
    }

    for (int i = 0; i < state->enemyCount; i++) {
        Entity *enemy = &state->enemies[i];
        if (enemy->isMoving) {
            float dx = enemy->targetX - enemy->visualX;
            float dy = enemy->targetY - enemy->visualY;
            float length = sqrt(dx * dx + dy * dy);

            if (length > 0) {
                dx /= length;
                dy /= length;
            }

            enemy->visualX += dx * state->pixelSpeed;
            enemy->visualY += dy * state->pixelSpeed;

            float distToTarget = sqrt(
                pow(enemy->targetX - enemy->visualX, 2) + 
                pow(enemy->targetY - enemy->visualY, 2)
            );

            if (distToTarget < state->pixelSpeed) {
                enemy->visualX = enemy->targetX;
                enemy->visualY = enemy->targetY;
                enemy->isMoving = 0;
            }

            updateLogicalPosition(enemy);
        }
    }
}

void applyGravity(GameState *state) {
    Entity *player = &state->player;

    if (!player->isMoving || player->moveDir != DOWN) {
        playerIsFalling = 0;
    }

    if (!player->isMoving && !supports(player->tileX, player->tileY) && 
        !isClimbable(player->tileX, player->tileY)) {

        if (player->tileY + 1 < HEIGHT && isWalkable(player->tileX, player->tileY + 1)) {
            player->targetX = (float)player->tileX;
            player->targetY = (float)(player->tileY + 1);
            player->isMoving = 1;
            player->moveDir = DOWN;
            playerIsFalling = 1;
        }
    }

    for (int i = 0; i < state->enemyCount; i++) {
        Entity *enemy = &state->enemies[i];
        if (!enemy->isMoving && !supports(enemy->tileX, enemy->tileY) && 
            !isClimbable(enemy->tileX, enemy->tileY)) {

            if (enemy->tileY + 1 < HEIGHT && isWalkable(enemy->tileX, enemy->tileY + 1)) {
                enemy->targetX = (float)enemy->tileX;
                enemy->targetY = (float)(enemy->tileY + 1);
                enemy->isMoving = 1;
                enemy->moveDir = DOWN;
            }
        }
    }
}

void checkForGold(GameState *state) {
   Entity *player = &state->player;
   if (map[player->tileY][player->tileX] == 'G') {
       map[player->tileY][player->tileX] = ' ';
       state->goldCollected++;
   }
}

void processKeyPress(int keyCode, GameState *state) {
    switch (keyCode) {
        case wimp_KEY_LEFT:
            keyPressedThisFrame[0] = 1;
            moveEntity(state, &state->player, LEFT, 1);
            break;
        case wimp_KEY_RIGHT:
            keyPressedThisFrame[1] = 1;
            moveEntity(state, &state->player, RIGHT, 1);
            break;
        case wimp_KEY_UP:
            keyPressedThisFrame[2] = 1;
            moveEntity(state, &state->player, UP, 1);
            break;
        case wimp_KEY_DOWN:
            keyPressedThisFrame[3] = 1;
            moveEntity(state, &state->player, DOWN, 1);
            break;
    }
}

void trackKeyStates(GameState *state) {
    Entity *player = &state->player;

    if (keyState[0] && !keyPressedThisFrame[0]) {
        if (player->isMoving && player->moveDir == LEFT) {
            player->targetX = player->visualX; 
            player->isMoving = 0;
        }
    }

    if (keyState[1] && !keyPressedThisFrame[1]) {
        if (player->isMoving && player->moveDir == RIGHT) {
            player->targetX = player->visualX; 
            player->isMoving = 0;
        }
    }

    for (int i = 0; i < 4; i++) {
        keyState[i] = keyPressedThisFrame[i];
        keyPressedThisFrame[i] = 0;
    }
}

void updateGame(void *ws) {
    GameState *state = (GameState *)ws;

    if (state->gameOver) {
        return;
    }

    trackKeyStates(state);

    state->frame++;

    updateMovementAnimation(state);
    if (!state->player.isMoving) {
        applyGravity(state);
    }
    checkForGold(state);

    char statusText[32];
    sprintf(statusText, "Gold: %d/%d", state->goldCollected, state->goldTotal);

    wimp_window_info window_info;
    window_info.w = gameWindow;
    xwimp_get_window_info_header_only(&window_info);
    strncpy(window_info.title_data.text, statusText, 31);

    updateWindow(gameWindow);

    setTimer(4, updateGame, ws);
}

void initialiseGame(GameState *state) {

    state->player.tileX = 5;
    state->player.tileY = 1;
    state->player.visualX = 5.0f;
    state->player.visualY = 1.0f;
    state->player.targetX = state->player.visualX;
    state->player.targetY = state->player.visualY;
    state->player.isMoving = 0;
    state->player.moveDir = NEUTRAL;

    state->enemyCount = 1;
    state->enemies[0].tileX = 15;
    state->enemies[0].tileY = 7;
    state->enemies[0].visualX = 15.0f;
    state->enemies[0].visualY = 7.0f;
    state->enemies[0].targetX = state->enemies[0].visualX;
    state->enemies[0].targetY = state->enemies[0].visualY;
    state->enemies[0].isMoving = 0;
    state->enemies[0].moveDir = NEUTRAL;

    state->goldCollected = 0;
    countGold(state);
    state->frame = 0;
    state->gameOver = 0;
    state->pixelSpeed = 0.15f;
    state->enemyUpdateCooldown = 0;

    setTimer(4, updateGame, (void*)state);
}

osbool update(wimp_event_no event, wimp_block* block) {
    switch(event) {
        case wimp_KEY_PRESSED:
            processKeyPress(block->key.c, &gameState);
            break;
        case wimp_REDRAW_WINDOW_REQUEST:
            redrawWindow(block);
            break;
        case wimp_OPEN_WINDOW_REQUEST:
            wimp_open_window(&block->open);
            break;
        case wimp_CLOSE_WINDOW_REQUEST:
            wimp_close_window(block->close.w);
            return TRUE;
        case wimp_USER_MESSAGE:
            break;
        case wimp_USER_MESSAGE_RECORDED:
            if(block->message.action == message_QUIT) {
                return TRUE;
            }
            break;
    }

    return FALSE;
}

int main() {

   wimp_initialise(wimp_VERSION_RO3, "Lode Runner", NULL, NULL);

   updateModeInfo();
   spriteArea = loadSpriteFile("<LodeRunner$Dir>.sprites");
   window = createWindow();
   block = createWimpBlock(window);

   initialiseTimer();
   initialiseGame(&gameState);

   xwimp_open_window(&block->open);

   osbool quit = FALSE;
   while(!quit) {
       wimp_event_no event = wimp_poll(0, block, NULL);

       if (event == wimp_NULL_REASON_CODE) {
           updateTimer();
       } else {
           quit = update(event, block);
       }
   }

   free(block);
   free(window);
   wimp_close_down(0);

   return 0;
}