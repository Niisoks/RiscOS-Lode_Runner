#include "main.h"
#include "entity.h"
#include "render.h"
#include "wimp.h"

char map[HEIGHT][WIDTH + 1];
int currentLevel = 1;


int loadMapFromFile(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        return 0;
    }
    
    // First clear the entire map
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            map[y][x] = ' ';
        }
        map[y][WIDTH] = '\0';
    }
    
    // Now read the file line by line
    char buffer[256];
    int y = 0;
    
    while (y < HEIGHT && fgets(buffer, sizeof(buffer), file)) {
        // Trim newline characters
        char *newline = strchr(buffer, '\n');
        if (newline) *newline = '\0';
        newline = strchr(buffer, '\r');
        if (newline) *newline = '\0';
        
        int len = strlen(buffer);
        int x;
        
        // Copy characters to map, but only up to WIDTH
        for (x = 0; x < WIDTH && x < len; x++) {
            map[y][x] = buffer[x];
        }
        
        y++;
    }
    
    fclose(file);
    
    // Print the loaded map to debug
    printf("Loaded map (%d rows):\n", y);
    for (int i = 0; i < HEIGHT; i++) {
        printf("[%s]\n", map[i]);
    }
    
    return 1;
}


GameState gameState;
os_t timer = 0;
void (*timerCallback)(void*) = NULL;
void *timerWorkspace = NULL;
os_t holeTimer[HEIGHT][WIDTH];
int dug[HEIGHT][WIDTH];
int playerIsFalling = 0;
int keyState[4] = {0, 0, 0, 0};
int keyPressedThisFrame[4] = {0, 0, 0, 0};

void initialiseTimer(void) {
    timer = 0;
    timerCallback = NULL;
    timerWorkspace = NULL;
}

void setTimer(int cs, void (*callback)(void*), void *ws) {
    timer = os_read_monotonic_time() + cs;
    timerCallback = callback;
    timerWorkspace = ws;   
}

void updateTimer(void) {
    if (timer > 0) {      
        os_t time = os_read_monotonic_time();
        if (time >= timer) {
            timer = 0;
            timerCallback(timerWorkspace);
        }
    }
}

void countGold(GameState *state) {
    int x, y;

    state->goldTotal = 0;
    for (y = 0; y < HEIGHT; y++) {
        for (x = 0; x < WIDTH; x++) {
            if (map[y][x] == 'G') {
                state->goldTotal++;
            }
        }
    }
}

void initialiseGame(GameState *state) {
    state->player.tileX = 6;
    state->player.tileY = 7;
    state->player.visualX = 6.0f;
    state->player.visualY = 7.0f;
    state->player.targetX = state->player.visualX;
    state->player.targetY = state->player.visualY;
    state->player.isMoving = 0;
    state->player.moveDir = NEUTRAL;
    state->player.inHole = 0;
    state->player.isDigging = 0;  
    state->player.digDirection = 0;
    state->player.digTimer = 0;

    state->enemyCount = 1;
    state->enemies[0].tileX = 15;
    state->enemies[0].tileY = 7;
    state->enemies[0].visualX = 15.0f;
    state->enemies[0].visualY = 7.0f;
    state->enemies[0].targetX = state->enemies[0].visualX;
    state->enemies[0].targetY = state->enemies[0].visualY;
    state->enemies[0].isMoving = 0;
    state->enemies[0].moveDir = NEUTRAL;
    state->enemies[0].inHole = 0;
    state->enemies[0].isDigging = 0;  
    state->enemies[0].digDirection = 0;
    state->enemies[0].digTimer = 0;

    initialiseAnimStates();

    state->goldCollected = 0;
    countGold(state);
    state->frame = 0;
    state->gameOver = 0;
    state->pixelSpeed = 0.15f;
    state->enemyUpdateCooldown = 0;

    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            holeTimer[y][x] = 0;
            dug[y][x] = 0;
        }
    }

    setTimer(4, updateGame, (void*)state);
}

void processKeyPress(int keyCode, GameState *state) {
    // Handle number keys for level switching
    if (keyCode >= '1' && keyCode <= '9') {
        int level = keyCode - '0';
        if (level != currentLevel) {
            loadLevel(level);
            return;
        }
    }
    
    switch (keyCode) {
        case wimp_KEY_LEFT:
            keyPressedThisFrame[0] = 1;
            moveEntity(state, &state->player, LEFT, 1);
            break;
        case wimp_KEY_RIGHT:
            keyPressedThisFrame[1] = 1;
            moveEntity(state, &state->player, RIGHT, 1);
            break;
        case wimp_KEY_UP:
            keyPressedThisFrame[2] = 1;
            moveEntity(state, &state->player, UP, 1);
            break;
        case wimp_KEY_DOWN:
            keyPressedThisFrame[3] = 1;
            moveEntity(state, &state->player, DOWN, 1);
            break;
        case 'z':
        case 'Z':
            dig(state, -1);
            break;
        case 'x':
        case 'X':
            dig(state, 1);
            break;
    }
}

void trackKeyStates(GameState *state) {
    Entity *player = &state->player;

    if (keyState[0] && !keyPressedThisFrame[0]) {
        if (player->isMoving && player->moveDir == LEFT) {
            player->targetX = player->visualX; 
            player->isMoving = 0;
        }
    }

    if (keyState[1] && !keyPressedThisFrame[1]) {
        if (player->isMoving && player->moveDir == RIGHT) {
            player->targetX = player->visualX; 
            player->isMoving = 0;
        }
    }

    for (int i = 0; i < 4; i++) {
        keyState[i] = keyPressedThisFrame[i];
        keyPressedThisFrame[i] = 0;
    }
}

void updateGame(void *ws) {
    GameState *state = (GameState *)ws;

    if (state->gameOver) {
        return;
    }

    trackKeyStates(state);

    state->frame++;

    if (state->player.isDigging) {
        state->player.digTimer--;
        if (state->player.digTimer <= 0) {
            state->player.isDigging = 0;
            
            if (keyState[0]) {
                moveEntity(state, &state->player, LEFT, 1);
            } else if (keyState[1]) {
                moveEntity(state, &state->player, RIGHT, 1);
            } else if (keyState[2]) {
                moveEntity(state, &state->player, UP, 1);
            } else if (keyState[3]) {
                moveEntity(state, &state->player, DOWN, 1);
            }
        }
    }

    updateMovementAnimation(state);
    updateAnimationFrames(state); 
    if (!state->player.isMoving) {
        applyGravity(state);
    }
    updateEnemies(state);
    updateHoleTimers(state);
    checkForGold(state);

    char statusText[48];
    sprintf(statusText, "Level: %d  Gold: %d/%d", currentLevel, state->goldCollected, state->goldTotal);

    wimp_window_info window_info;
    window_info.w = gameWindow;
    xwimp_get_window_info_header_only(&window_info);
    strncpy(window_info.title_data.text, statusText, 31);

    if (checkCollision(state)) {
        state->gameOver = 1;
        strncpy(window_info.title_data.text, "Game Over! Press any number key to restart", 42);
    }
    
    // Check if all gold is collected
    if (state->goldCollected >= state->goldTotal) {
        // Display success message
        sprintf(window_info.title_data.text, "Level %d Complete! Press a number for next level", currentLevel);
    }

    updateWindow(gameWindow);

    setTimer(4, updateGame, ws);
}

void loadLevel(int level) {
    char filename[256];
    currentLevel = level;
    
    // Create the filename based on the level number
    sprintf(filename, "<LodeRunner$Dir>.maps.level%d", level);
    
    // Attempt to load the map
    if (!loadMapFromFile(filename)) {
        // If file doesn't exist, create a default map
        const char* defaultMap[] = {
            "####################",
            "#   G    H   G     #",
            "#  H###H###H#####  #",
            "#  H#  H  #H       #",
            "#  H# #H# #H  ######",
            "#  H# #H# #H    G  #",
            "# #H# #H# #####H#  #",
            "#  H   H#---G  H   #",
            "#  H   H     H######",
            "#  H   H-----H#    #",
            "#  H --H           #",
            "#  H   H    ##H    #",
            "#  H   H      H    #",
            "GGGGGGGGGGGGGGGGGGGG"
        };
        
        for (int y = 0; y < HEIGHT && y < 14; y++) {
            strncpy(map[y], defaultMap[y], WIDTH);
            map[y][WIDTH] = '\0';
        }
    }
    
    // Reinitialize the game state with the new map
    initialiseGame(&gameState);
}

int main(void) {
   wimp_initialise(wimp_VERSION_RO3, "Lode Runner", NULL, NULL);

   updateModeInfo();
   spriteArea = loadSpriteFile("<LodeRunner$Dir>.sprites");
   
   // Load the first level
   loadLevel(1);
   
   window = createWindow();
   createWimpBlock(window);

   initialiseTimer();
   initialiseGame(&gameState);

   xwimp_open_window(&block->open);

   osbool quit = FALSE;
   while(!quit) {
       wimp_event_no event = wimp_poll(0, block, NULL);

       if (event == wimp_NULL_REASON_CODE) {
           updateTimer();
       } else {
           quit = update(event, block);
       }
   }

   free(block);
   free(window);
   wimp_close_down(0);

   return 0;
}