#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "oslib/wimp.h"
#include "oslib/os.h"        
#include "oslib/osfile.h"
#include "oslib/osspriteop.h"                    
#include "oslib/colourtrans.h"

static osbool main_quit_flag = FALSE;

static void main_initialise(void);
static void main_poll(void);
static void main_terminate(void);

os_t timer;

void (*timerCallback)(void*);       

void *timerWorkspace;

void initialiseTimer()
{         
   timer          = 0;
   timerCallback  = NULL;
   timerWorkspace = NULL;
}

void setTimer(int cs, void (*callback)(void*), void *ws)
{
   timer          = os_read_monotonic_time() + cs;
   timerCallback  = callback;
   timerWorkspace = ws;   
}

void updateTimer()
{
   if (timer > 0)
   {      
      os_t time = os_read_monotonic_time();

      if (time >= timer)
      {
         timer = 0;
         printf("Jobs done");
         timerCallback(timerWorkspace);
      }
   }
}

typedef struct 
{                                       
   osspriteop_header *sprite;

   int x, y;   // coordinates of invader

   int dx, dy;  // velocity of invader

   int frame;
}
GameState;
 
GameState state;


// A lot of the code here is heavily referenced / lifted from gavins work. Consider this a temporary library of sorts.
wimp_window *window;
wimp_block  *block;

wimp_window* createWindow()
{
   wimp_window* window = (wimp_window*)malloc(sizeof(wimp_window));

   window->visible.x0   = 0;
   window->visible.y0   = 0;
   window->visible.x1   = 1000;
   window->visible.y1   = 1000;
   window->xscroll      = 0;
   window->yscroll      = 0;
   window->next         = wimp_TOP;
   window->flags        = wimp_WINDOW_MOVEABLE
                        | wimp_WINDOW_BACK_ICON
                        | wimp_WINDOW_CLOSE_ICON
                        | wimp_WINDOW_TITLE_ICON
                        | wimp_WINDOW_HSCROLL
                        | wimp_WINDOW_VSCROLL
                        | wimp_WINDOW_TOGGLE_ICON
                        | wimp_WINDOW_SIZE_ICON
                        | wimp_WINDOW_NEW_FORMAT;
   window->title_fg     = wimp_COLOUR_BLACK;
   window->title_bg     = wimp_COLOUR_LIGHT_GREY;
   window->work_fg      = wimp_COLOUR_WHITE;
   window->work_bg      = wimp_COLOUR_BLACK;
   window->scroll_outer = wimp_COLOUR_MID_LIGHT_GREY;
   window->scroll_inner = wimp_COLOUR_VERY_LIGHT_GREY;
   window->extent.x0    = 0;
   window->extent.y0    = 0;
   window->extent.x1    = 1000;
   window->extent.y1    = 1000;
   window->title_flags  = wimp_ICON_TEXT
                        | wimp_ICON_HCENTRED
                        | wimp_ICON_VCENTRED;
   window->work_flags   = wimp_BUTTON_CLICK << wimp_ICON_BUTTON_TYPE_SHIFT;
   window->sprite_area  = 0;
   window->xmin         = 0;
   window->ymin         = 0;
   window->icon_count   = 0;

   strncpy(window->title_data.text, "Lode Runner", 12);

   return window;
}


typedef union
{        
   int numbers[14];

   struct
   {    
      int modeFlags,
          scrRCol,
          scrBRow,
          nColour,
          xEigFactor,
          yEigFactor,
          lineLength,  
          screenSize,
          yShiftSize,
          log2bpp,
          log2bpc,
          xWindLimit,
          yWindLimit,
          minScreenBanks;
   }
   info;
}
ModeInfo;      

ModeInfo modeInfo;
         
void updateModeInfo()
{                                      
   for (int i = 0; i < 15; i++)
   {
      modeInfo.numbers[i] = i;
   }

   modeInfo.numbers[14] = -1;

   os_error *e = xos_read_vdu_variables((os_vdu_var_list*)modeInfo.numbers, 
                                        modeInfo.numbers);

}

osspriteop_area *area;

osspriteop_header *invader1, *invader2;

os_factors factors;

osspriteop_trans_tab *transTab;

void updateGame(void *ws)
{                                               
        printf("WE KINDA DO UPDATE DOE")     ;
   GameState* state = (GameState*)ws;
    
   state->frame++;              

   if (state->frame%4 == 0)
   {
      state->sprite = state->sprite == invader1 ? invader2 : invader1; 
   }

//    if ((state->x >> 8) >= 640 - 72)
//    {
//       state->dx = -(2 << 8);
//    }                        
//    else if ((state->x >> 8) < 0)
//    {
//       state->dx = +(2 << 8);
//    }  

//    if ((state->y >> 8) >= 512 - 68)
//    {
//       state->dy = -(2 << 8);
//    }                        
//    else if ((state->y >> 8) < 0)
//    {
//       state->dy = +(2 << 8);
//    } 

//    state->x += state->dx;
//    state->y += state->dy;

   wimp_force_redraw(block->open.w, 0, 0, 1000, +1000); 

   setTimer(4, updateGame, ws);   
}

void initialiseGame(GameState *state)
{
   state->sprite = invader1;
   state->x      = 320 << 8;
   state->y      = 256 << 8;
   state->dx     = 2 << 8;
   state->dy     = 2 << 8;
   state->frame  = 0;

   setTimer(64, updateGame, (void*)state);
}

osspriteop_area* loadSpriteFile(const char *filename)
{                                                       
   int size;

   bits type;

   fileswitch_object_type objType;

   xosfile_read_stamped_no_path(filename, &objType, NULL, NULL, &size, NULL, &type);
   
   size += sizeof(int);

   osspriteop_area *area = malloc(size);

   area->size  = size;
   area->first = 16; // Size of the sprite?
   
   xosspriteop_load_sprite_file(osspriteop_USER_AREA, area, filename);

   // determine more efficient sprite pointer ids                                  
   os_error *e = xosspriteop_select_sprite(osspriteop_USER_AREA, 
                                     area, 
                                     (osspriteop_id)"runner1",
                                     &invader1);

        if(e != NULL){
                printf("Problem with sprite 1");
                
        }
    
   e = xosspriteop_select_sprite(osspriteop_USER_AREA, 
                                 area, 
                                 (osspriteop_id)"runner2",
                                 &invader2);

        if(e != NULL){
                printf("Problem with sprite 2");
        }    
   // set up factors and translation table

   factors.xmul = 1<<(modeInfo.info.xEigFactor-1);
   factors.ymul = 1<<(modeInfo.info.yEigFactor);
   factors.xdiv = 1;
   factors.ydiv = 1;         

   e = xcolourtrans_generate_table_for_sprite(area,  
                                       (osspriteop_id)"runner1",    
                                       (os_mode)-1,   
                                       (os_palette*)-1,    
                                       NULL,
                                       colourtrans_CURRENT_IF_ABSENT |
                                       colourtrans_RETURN_WIDE_ENTRIES,
                                       NULL,
                                       NULL,
                                       &size);

   transTab = malloc(size);

   e = xcolourtrans_generate_table_for_sprite(area, 
                                    (osspriteop_id)"runner2",   
                                    (os_mode)-1,   
                                    (os_palette*)-1,   
                                    transTab,
                                    colourtrans_CURRENT_IF_ABSENT |
                                    colourtrans_RETURN_WIDE_ENTRIES,
                                    NULL,
                                    NULL,
                                    &size);
   
   
   return area;
}

wimp_block* createWimpBlock(wimp_window* window)
{
   wimp_block* block = (wimp_block*)malloc(sizeof(wimp_block));

   block->open.w       = wimp_create_window(window);
   block->open.visible = window->visible;
   block->open.xscroll = window->xscroll;
   block->open.yscroll = window->yscroll;
   block->open.next    = window->next;

   return block;
}

void redrawWindow(wimp_block *block)
{
    wimp_draw draw;

    draw.w = block->redraw.w;
    draw.box = block->redraw.box;

    int more;
    xwimp_redraw_window(&draw, &more); 
    while (more)
    {
        int x = draw.box.x0 - draw.xscroll;
        int y = draw.box.y1 - draw.yscroll; 

        os_error *e = xosspriteop_put_sprite_scaled(osspriteop_PTR,
                        area,
                        (osspriteop_id)state.sprite,
                        x + (state.x >> 8),
                       y + (state.y >> 8),
                        os_ACTION_OVERWRITE |
                        osspriteop_GIVEN_WIDE_ENTRIES | 0x8,
                        &factors,
                        transTab);
        
        xwimp_get_rectangle(&draw, &more);

//     while (more)
//     {
//         int x0 = draw.box.x0 - 150;
//         int y0 = draw.box.y0 - 150;
//         int x1 = draw.box.x1 - 300;
//         int y1 = draw.box.y1 - 300;

//         os_set_colour(os_COLOUR_SET_BG, os_COLOUR_WHITE);
//         os_plot(os_MOVE_TO, x0, y0);    
//         os_plot(os_PLOT_TO, x0, y1);    
//         os_plot(os_PLOT_TO, x1, y1);    
//         os_plot(os_PLOT_TO, x1, y0);    
//         os_plot(os_PLOT_TO, x0, y0);    

//         xwimp_get_rectangle(&draw, &more); 
    }
}

osbool update(wimp_event_no event, wimp_block* block)
{
   switch(event)
   {
      case wimp_REDRAW_WINDOW_REQUEST:
      {
         redrawWindow(block);

         break;
      }
      case wimp_OPEN_WINDOW_REQUEST:
      {
         wimp_open_window(&block->open);

         break;
      }
      case wimp_CLOSE_WINDOW_REQUEST:
      {
         wimp_close_window(block->close.w);

         return TRUE;
      }
      case wimp_USER_MESSAGE:
      case wimp_USER_MESSAGE_RECORDED:
      {
         if(block->message.action == message_QUIT)
         {
            return TRUE;
         }

         break;
      }
   }

   return FALSE;
}

int main(int argc, char *argv[])
{
  main_initialise();
  main_poll();
  main_terminate();

  return 0;
}

static void main_initialise(void)
{
        wimp_initialise(wimp_VERSION_RO3, "Loderunner", NULL, NULL);
        updateModeInfo();
        area = loadSpriteFile("<Loderunner$Dir>.sprites");
        window = createWindow();
        block = createWimpBlock(window);

        block->open.visible.x0 = 0;
        block->open.visible.y0 = 0;
        block->open.visible.x1 = 1000;
        block->open.visible.y1 = 1000;

        

        xwimp_open_window(&block->open);
           initialiseTimer();
   initialiseGame(&state);

}

static void main_poll(void)
{
  wimp_event_no reason;

  while(!main_quit_flag){
    updateTimer();
    reason = wimp_poll(
                wimp_MASK_NULL | wimp_MASK_ENTERING | wimp_MASK_LEAVING |
                wimp_MASK_GAIN | wimp_MASK_LOSE | wimp_MASK_POLLWORD,
                block,
                NULL
    );
    main_quit_flag = update(reason, block);
  }
  return 0;
}

static void main_terminate(void)
{
        free(block);
        free(window);
        wimp_close_down(0);
}
