#include "render.h"
#include "entity.h"

void render(wimp_draw *draw, osbool more) {
    int x, y, i;
    GameState *state = &gameState;

    while (more) {
        int baseX = draw->box.x0 - draw->xscroll;
        int baseY = draw->box.y1 - draw->yscroll - TILE_SIZE;

        for (y = 0; y < HEIGHT; y++) {
            for (x = 0; x < WIDTH; x++) {
                int screenX = baseX + (x * TILE_SIZE);
                int screenY = baseY - (y * TILE_SIZE);
                osspriteop_header *sprite = NULL;

                switch (map[y][x]) {
                    case '#': sprite = wallSprite; break;
                    case 'H': sprite = ladderSprite; break;
                    case 'G': sprite = goldSprite; break;
                    case '.': sprite = holeSprite; break;
                    case '-': sprite = tightropeSprite; break;
                }

                if (sprite != NULL) {
                    xosspriteop_put_sprite_scaled(
                        osspriteop_PTR, spriteArea, (osspriteop_id)sprite,
                        screenX, screenY, 
                        os_ACTION_OVERWRITE | osspriteop_GIVEN_WIDE_ENTRIES | osspriteop_USE_MASK,
                        &factors, transTab
                    );
                }
            }
        }

        int playerScreenX = baseX + (int)(state->player.visualX * TILE_SIZE);
        int playerScreenY = baseY - (int)(state->player.visualY * TILE_SIZE);
        osspriteop_header *playerSprite = getEntitySprite(&state->player, state, 1, 0); 

        if (playerSprite != NULL) {
            xosspriteop_put_sprite_scaled(
                osspriteop_PTR, spriteArea, (osspriteop_id)playerSprite,
                playerScreenX, playerScreenY,
                os_ACTION_OVERWRITE | osspriteop_GIVEN_WIDE_ENTRIES | osspriteop_USE_MASK,
                &factors, transTab
            );
        }

        for (i = 0; i < state->enemyCount; i++) {
            Entity *enemy = &state->enemies[i];
            int enemyScreenX = baseX + (int)(enemy->visualX * TILE_SIZE);
            int enemyScreenY = baseY - (int)(enemy->visualY * TILE_SIZE);
            osspriteop_header *enemySprite = getEntitySprite(enemy, state, 0, i);

            xosspriteop_put_sprite_scaled(
                osspriteop_PTR, spriteArea, (osspriteop_id)enemySprite,
                enemyScreenX, enemyScreenY,
                os_ACTION_OVERWRITE | osspriteop_GIVEN_WIDE_ENTRIES | osspriteop_USE_MASK,
                &factors, transTab
            );
        }

        xwimp_get_rectangle(draw, &more);
    }
}

int isTightrope(int x, int y) {
    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT)
        return 0;

    return (map[y][x] == '-');
}

int isWalkable(int x, int y, GameState *state) {
    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT)
        return 0;

    char tile = map[y][x];

    if (tile == '.' && dug[y][x]) {
        for (int i = 0; i < state->enemyCount; i++) {
            Entity *enemy = &state->enemies[i];
            if (enemy->tileX == x && enemy->tileY == y && enemy->inHole) {
                return 1;  
            }
        }
    }

    return (tile == ' ' || tile == 'G' || tile == 'H' || tile == '.' || tile == '-');
}

int isOnTightrope(int x, int y) {
    return (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT && map[y][x] == '-');
}

int isClimbable(int x, int y) {
    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT)
        return 0;

    return (map[y][x] == 'H');
}

int isSolid(int x, int y) {
    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT)
        return 0;

    return (map[y][x] == '#' || map[y][x] == 'G');
}

int isLadderTop(int x, int y) {
    return y + 1 < HEIGHT && map[y + 1][x] == 'H' && map[y][x] != 'H' && map[y][x] != '#';
}

int supports(int x, int y, GameState *state) {
    if (y + 1 >= HEIGHT) return 1;  

    if (y + 1 < HEIGHT && map[y + 1][x] == '.' && dug[y + 1][x]) {
        for (int i = 0; i < state->enemyCount; i++) {
            Entity *enemy = &state->enemies[i];
            if (enemy->tileX == x && enemy->tileY == y + 1 && enemy->inHole) {
                return 1;  
            }
        }
    }

    return isSolid(x, y + 1) || isLadderTop(x, y) || isClimbable(x, y);
}

int isInHole(int x, int y) {
    return x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT && 
           map[y][x] == '.' && holeTimer[y][x] > 0;
}

void checkForGold(GameState *state) {
   Entity *player = &state->player;
   if (map[player->tileY][player->tileX] == 'G') {
       map[player->tileY][player->tileX] = ' ';
       state->goldCollected++;
   }
}