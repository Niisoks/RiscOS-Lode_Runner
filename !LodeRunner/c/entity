#include "entity.h"
#include "render.h"
#include <stdlib.h>
#include <math.h>

AnimationState playerAnim;
AnimationState enemyAnims[5];

void initialiseAnimStates(void) {
    playerAnim.walkFrame = 0;
    playerAnim.climbFrame = 0;
    playerAnim.ropeFrame = 0;
    playerAnim.fallFrame = 0;
    playerAnim.lastWalkFrame = 0;
    playerAnim.lastClimbFrame = 0;
    playerAnim.lastRopeFrame = 0;

    for (int i = 0; i < 5; i++) {
        enemyAnims[i].walkFrame = 0;
        enemyAnims[i].climbFrame = 0;
        enemyAnims[i].ropeFrame = 0;
        enemyAnims[i].fallFrame = 0;
        enemyAnims[i].lastWalkFrame = 0;
        enemyAnims[i].lastClimbFrame = 0;
        enemyAnims[i].lastRopeFrame = 0;
    }
}

void updateAnimationFrames(GameState *state) {
    Entity *player = &state->player;

    if (player->isMoving) {
        if ((player->moveDir == LEFT || player->moveDir == RIGHT) && !isOnTightrope(player->tileX, player->tileY)) {
            playerAnim.walkFrame = (playerAnim.walkFrame + 1) % 4;
            playerAnim.lastWalkFrame = playerAnim.walkFrame;
        }
        else if ((player->moveDir == LEFT || player->moveDir == RIGHT) && isOnTightrope(player->tileX, player->tileY)) {
            playerAnim.ropeFrame = (playerAnim.ropeFrame + 1) % 4;
            playerAnim.lastRopeFrame = playerAnim.ropeFrame;
        }
        else if ((player->moveDir == UP || player->moveDir == DOWN) && isClimbable(player->tileX, player->tileY)) {
            playerAnim.climbFrame = (playerAnim.climbFrame + 1) % 4;
            playerAnim.lastClimbFrame = playerAnim.climbFrame;
        }
    }

    if (playerIsFalling) {
        playerAnim.fallFrame = (playerAnim.fallFrame + 1) % 2;
    }

    for (int i = 0; i < state->enemyCount; i++) {
        Entity *enemy = &state->enemies[i];

        if (enemy->isMoving) {
            if ((enemy->moveDir == LEFT || enemy->moveDir == RIGHT) && !isOnTightrope(enemy->tileX, enemy->tileY)) {
                enemyAnims[i].walkFrame = (enemyAnims[i].walkFrame + 1) % 4;
                enemyAnims[i].lastWalkFrame = enemyAnims[i].walkFrame;
            }
            else if ((enemy->moveDir == LEFT || enemy->moveDir == RIGHT) && isOnTightrope(enemy->tileX, enemy->tileY)) {
                enemyAnims[i].ropeFrame = (enemyAnims[i].ropeFrame + 1) % 4;
                enemyAnims[i].lastRopeFrame = enemyAnims[i].ropeFrame;
            }
            else if ((enemy->moveDir == UP || enemy->moveDir == DOWN) && isClimbable(enemy->tileX, enemy->tileY)) {
                enemyAnims[i].climbFrame = (enemyAnims[i].climbFrame + 1) % 4;
                enemyAnims[i].lastClimbFrame = enemyAnims[i].climbFrame;
            }

            if (enemy->moveDir == DOWN && !isClimbable(enemy->tileX, enemy->tileY) && !isOnTightrope(enemy->tileX, enemy->tileY)) {
                enemyAnims[i].fallFrame = (enemyAnims[i].fallFrame + 1) % 2;
            }
        }
    }
}

osspriteop_header* getEntitySprite(Entity *entity, GameState *state, int isPlayer, int entityIndex) {
    AnimationState *anim;

    if (isPlayer) {
        anim = &playerAnim;
    } else {
        anim = &enemyAnims[entityIndex];
    }

    if (entity->inHole) {
        return isPlayer ? playerFallSprite2 : enemyFallSprite2;
    }

    if (isPlayer && entity->isDigging) {
        return (state->frame % 4 < 2) ? playerDigSprite1 : playerDigSprite2;
    }

    if ((isPlayer && playerIsFalling) || 
        (!isPlayer && entity->moveDir == DOWN && !isClimbable(entity->tileX, entity->tileY) && !isOnTightrope(entity->tileX, entity->tileY))) {
        if (isPlayer) {
            return (anim->fallFrame == 0) ? playerFallSprite1 : playerFallSprite2;
        } else {
            return (anim->fallFrame == 0) ? enemyFallSprite1 : enemyFallSprite2;
        }
    }

    if (isOnTightrope(entity->tileX, entity->tileY)) {
        if (entity->isMoving && (entity->moveDir == LEFT || entity->moveDir == RIGHT)) {
            if (isPlayer) {
                switch (anim->ropeFrame) {
                    case 0: return playerRopeSprite1;
                    case 1: return playerRopeSprite2;
                    case 2: return playerRopeSprite3;
                    case 3: return playerRopeSprite4;
                }
            } else {
                switch (anim->ropeFrame) {
                    case 0: return enemyRopeSprite1;
                    case 1: return enemyRopeSprite2;
                    case 2: return enemyRopeSprite3;
                    case 3: return enemyRopeSprite4;
                }
            }
        } else {
            if (isPlayer) {
                switch (anim->lastRopeFrame) {
                    case 0: return playerRopeSprite1;
                    case 1: return playerRopeSprite2;
                    case 2: return playerRopeSprite3;
                    case 3: return playerRopeSprite4;
                    default: return playerRopeSprite1;
                }
            } else {
                switch (anim->lastRopeFrame) {
                    case 0: return enemyRopeSprite1;
                    case 1: return enemyRopeSprite2;
                    case 2: return enemyRopeSprite3;
                    case 3: return enemyRopeSprite4;
                    default: return enemyRopeSprite1;
                }
            }
        }
    }

    if (isClimbable(entity->tileX, entity->tileY)) {
        if (entity->isMoving && (entity->moveDir == UP || entity->moveDir == DOWN)) {
            if (isPlayer) {
                switch (anim->climbFrame) {
                    case 0: return playerClimbSprite1;
                    case 1: return playerClimbSprite2;
                    case 2: return playerClimbSprite3;
                    case 3: return playerClimbSprite4;
                }
            } else {
                switch (anim->climbFrame) {
                    case 0: return enemyClimbSprite1;
                    case 1: return enemyClimbSprite2;
                    case 2: return enemyClimbSprite3;
                    case 3: return enemyClimbSprite4;
                }
            }
        } else {
            if (isPlayer) {
                switch (anim->lastClimbFrame) {
                    case 0: return playerClimbSprite1;
                    case 1: return playerClimbSprite2;
                    case 2: return playerClimbSprite3;
                    case 3: return playerClimbSprite4;
                    default: return playerClimbSprite1;
                }
            } else {
                switch (anim->lastClimbFrame) {
                    case 0: return enemyClimbSprite1;
                    case 1: return enemyClimbSprite2;
                    case 2: return enemyClimbSprite3;
                    case 3: return enemyClimbSprite4;
                    default: return enemyClimbSprite1;
                }
            }
        }
    }

    if (entity->isMoving && (entity->moveDir == LEFT || entity->moveDir == RIGHT)) {
        if (isPlayer) {
            switch (anim->walkFrame) {
                case 0: return playerSprite1;
                case 1: return playerSprite2;
                case 2: return playerSprite3;
                case 3: return playerSprite4;
            }
        } else {
            switch (anim->walkFrame) {
                case 0: return enemySprite1;
                case 1: return enemySprite2;
                case 2: return enemySprite3;
                case 3: return enemySprite4;
            }
        }
    } else {
        if (isPlayer) {
            switch (anim->lastWalkFrame) {
                case 0: return playerSprite1;
                case 1: return playerSprite2;
                case 2: return playerSprite3;
                case 3: return playerSprite4;
                default: return playerSprite1;
            }
        } else {
            switch (anim->lastWalkFrame) {
                case 0: return enemySprite1;
                case 1: return enemySprite2;
                case 2: return enemySprite3;
                case 3: return enemySprite4;
                default: return enemySprite1;
            }
        }
    }

    return isPlayer ? playerSprite1 : enemySprite1;
}

void moveEntity(GameState *state, Entity *entity, Direction dir, int isPlayer) {
    if (entity->inHole) return;
    
    if (isPlayer && entity->isDigging) return;

    if (isPlayer) {
        if (playerIsFalling && (dir == LEFT || dir == RIGHT) && !isOnTightrope(entity->tileX, entity->tileY)) {
            return;
        }

        if (entity->isMoving && entity->moveDir == DOWN && 
            !isClimbable(entity->tileX, entity->tileY) && 
            !isOnTightrope(entity->tileX, entity->tileY) &&
            (dir == LEFT || dir == RIGHT)) {
            return;
        }
    }

    if (!entity->isMoving || entity->moveDir != dir) {
        int tileX = entity->tileX;
        int tileY = entity->tileY;

        if (dir == LEFT || dir == RIGHT) {
            int nextX = tileX + (dir == LEFT ? -1 : 1);

            if (isWalkable(nextX, tileY, state)) {
                if (isTightrope(tileX, tileY)) {
                    entity->targetX = (float)nextX;
                    entity->targetY = (float)tileY;
                    entity->isMoving = 1;
                    entity->moveDir = dir;
                    return;
                }

                if (isClimbable(tileX, tileY) && isTightrope(nextX, tileY)) {
                    entity->targetX = (float)nextX;
                    entity->targetY = (float)tileY;
                    entity->isMoving = 1;
                    entity->moveDir = dir;
                    return;
                }

                entity->targetX = (float)nextX;
                entity->targetY = (float)tileY;
                entity->isMoving = 1;
                entity->moveDir = dir;
            }
            else if (isPlayer && isSolid(nextX, tileY)) {
                float partialX;

                if (dir == LEFT) {
                    partialX = (float)tileX - WALL_PADDING;
                } else { 
                    partialX = (float)tileX + WALL_PADDING;
                }

                entity->targetX = partialX;
                entity->targetY = (float)tileY;
                entity->isMoving = 1;
                entity->moveDir = dir;
            }
        } 
        else if (dir == UP) {
            if (isClimbable(tileX, tileY)) {
                if (tileY > 0 && (isClimbable(tileX, tileY-1) || isWalkable(tileX, tileY-1, state))) {
                    entity->targetX = (float)tileX;
                    entity->targetY = (float)(tileY - 1);
                    entity->isMoving = 1;
                    entity->moveDir = dir;
                }
                else if (isPlayer && tileY > 0 && isSolid(tileX, tileY-1)) {
                    entity->targetX = (float)tileX;
                    entity->targetY = (float)tileY - WALL_PADDING;
                    entity->isMoving = 1;
                    entity->moveDir = dir;
                }
            }
        }
        else if (dir == DOWN) {
            if (isOnTightrope(tileX, tileY)) {
                if (tileY < HEIGHT-1 && isWalkable(tileX, tileY+1, state)) {
                    entity->targetX = (float)tileX;
                    entity->targetY = (float)(tileY + 1);
                    entity->isMoving = 1;
                    entity->moveDir = dir;
                }
            }
            else if (isClimbable(tileX, tileY) || 
                (tileY < HEIGHT-1 && isClimbable(tileX, tileY+1) && supports(tileX, tileY, state))) {
                if (tileY < HEIGHT-1 && 
                    (isClimbable(tileX, tileY+1) || isLadderTop(tileX, tileY))) {
                    entity->targetX = (float)tileX;
                    entity->targetY = (float)(tileY + 1);
                    entity->isMoving = 1;
                    entity->moveDir = dir;
                }
                else if (isPlayer && tileY < HEIGHT-1 && isSolid(tileX, tileY+1)) {
                    entity->targetX = (float)tileX;
                    entity->targetY = (float)tileY + WALL_PADDING;
                    entity->isMoving = 1;
                    entity->moveDir = dir;
                }
            }
        }
    }
}

void updateLogicalPosition(Entity *entity) {
    entity->tileX = (int)round(entity->visualX);
    entity->tileY = (int)round(entity->visualY);
}

void updateMovementAnimation(GameState *state) {
    Entity *player = &state->player;
    if (player->isMoving) {
        float dx = player->targetX - player->visualX;
        float dy = player->targetY - player->visualY;
        float length = sqrt(dx * dx + dy * dy);

        if (length > 0) {
            dx /= length;
            dy /= length;
        }

        player->visualX += dx * state->pixelSpeed;
        player->visualY += dy * state->pixelSpeed;

        float distToTarget = sqrt(
            pow(player->targetX - player->visualX, 2) + 
            pow(player->targetY - player->visualY, 2)
        );

        if (distToTarget < state->pixelSpeed) {
            player->visualX = player->targetX;
            player->visualY = player->targetY;
            player->isMoving = 0;

            if (playerIsFalling && player->moveDir == DOWN) {
                playerIsFalling = 0;
            }
        }

        updateLogicalPosition(player);
    }

    for (int i = 0; i < state->enemyCount; i++) {
        Entity *enemy = &state->enemies[i];
        if (enemy->isMoving) {
            float dx = enemy->targetX - enemy->visualX;
            float dy = enemy->targetY - enemy->visualY;
            float length = sqrt(dx * dx + dy * dy);

            if (length > 0) {
                dx /= length;
                dy /= length;
            }

            enemy->visualX += dx * state->pixelSpeed;
            enemy->visualY += dy * state->pixelSpeed;

            float distToTarget = sqrt(
                pow(enemy->targetX - enemy->visualX, 2) + 
                pow(enemy->targetY - enemy->visualY, 2)
            );

            if (distToTarget < state->pixelSpeed) {
                enemy->visualX = enemy->targetX;
                enemy->visualY = enemy->targetY;
                enemy->isMoving = 0;
            }

            updateLogicalPosition(enemy);
        }
    }
}

int isEnemyInHoleAt(GameState *state, int x, int y) {
    if (!(x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT && 
          map[y][x] == '.' && dug[y][x])) {
        return 0;
    }

    for (int i = 0; i < state->enemyCount; i++) {
        Entity *enemy = &state->enemies[i];
        if (enemy->tileX == x && enemy->tileY == y && enemy->inHole) {
            return 1;
        }
    }

    return 0;
}

void applyGravity(GameState *state) {
    Entity *player = &state->player;

    if (!player->isMoving || player->moveDir != DOWN) {
        playerIsFalling = 0;
    }

    if (!player->isMoving && !isInHole(player->tileX, player->tileY) && 
        !supports(player->tileX, player->tileY, state) && 
        !isOnTightrope(player->tileX, player->tileY) && 
        !isClimbable(player->tileX, player->tileY)) {

        if (player->tileY + 1 < HEIGHT && isWalkable(player->tileX, player->tileY + 1, state)) {
            player->targetX = (float)player->tileX;
            player->targetY = (float)(player->tileY + 1);
            player->isMoving = 1;
            player->moveDir = DOWN;
            playerIsFalling = 1;
        }
    }

    for (int i = 0; i < state->enemyCount; i++) {
        Entity *enemy = &state->enemies[i];
        if (!enemy->isMoving && !isInHole(enemy->tileX, enemy->tileY) && 
            !supports(enemy->tileX, enemy->tileY, state) && 
            !isOnTightrope(enemy->tileX, enemy->tileY) && 
            !isClimbable(enemy->tileX, enemy->tileY)) {

            if (enemy->tileY + 1 < HEIGHT && isWalkable(enemy->tileX, enemy->tileY + 1, state)) {
                enemy->targetX = (float)enemy->tileX;
                enemy->targetY = (float)(enemy->tileY + 1);
                enemy->isMoving = 1;
                enemy->moveDir = DOWN;
            }
        }
    }
}

void updateEnemies(GameState *state) {
    if (++state->enemyUpdateCooldown < 12) return;
    state->enemyUpdateCooldown = 0;

    for (int i = 0; i < state->enemyCount; i++) {
        Entity *enemy = &state->enemies[i];
        if (enemy->isMoving || enemy->inHole) continue;

        int enemyX = enemy->tileX;
        int enemyY = enemy->tileY;
        int playerX = state->player.tileX;
        int playerY = state->player.tileY;

        int dx = playerX - enemyX;
        int dy = playerY - enemyY;

        Direction dir = NEUTRAL;

        if (isOnTightrope(enemyX, enemyY)) {
            if (dy > 2 && abs(dx) > 1) {
                dir = DOWN;
            }
            else if (dx != 0) {
                dir = dx < 0 ? LEFT : RIGHT;
            }
            else if (isWalkable(enemyX - 1, enemyY, state)) {
                dir = LEFT;
            } 
            else if (isWalkable(enemyX + 1, enemyY, state)) {
                dir = RIGHT;
            }
        }
        else {
            if (abs(dy) > abs(dx)) {
                if (dy < 0 && isClimbable(enemyX, enemyY)) {
                    dir = UP;
                } 
                else if (dy > 0) {
                    if (isClimbable(enemyX, enemyY)) {
                        dir = DOWN;
                    }
                    else {
                        dir = dx < 0 ? LEFT : RIGHT;
                    }
                }
            } 
            else if (dx != 0) {
                if ((dx < 0 && isOnTightrope(enemyX - 1, enemyY)) || 
                    (dx > 0 && isOnTightrope(enemyX + 1, enemyY))) {
                    dir = dx < 0 ? LEFT : RIGHT;
                }
                else {
                    dir = dx < 0 ? LEFT : RIGHT;
                }
            }
        }

        if (dir != NEUTRAL) {
            moveEntity(state, enemy, dir, 0);  
        }
    }
}

int checkCollision(GameState *state) {
    Entity *player = &state->player;

    for (int i = 0; i < state->enemyCount; i++) {
        Entity *enemy = &state->enemies[i];

        if (enemy->tileX == player->tileX && enemy->tileY == player->tileY && !enemy->inHole) {
            return 1;
        }
    }

    return 0;
}

void dig(GameState *state, int dx) {
    Entity *player = &state->player;
    int x = player->tileX + dx;
    int y = player->tileY + 1;

    if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT && map[y][x] == '#') {
        map[y][x] = '.';
        holeTimer[y][x] = os_read_monotonic_time();
        dug[y][x] = 1;

        player->isDigging = 1;
        player->digDirection = dx;
        player->digTimer = 20; 
    }
}

int findSafePosition(int x, int y, int *newX, int *newY) {
    int dx[] = {0, -1, 1, 0, -1, -1, 1, 1};
    int dy[] = {-1, 0, 0, 1, -1, 1, -1, 1};

    for (int i = 0; i < 8; i++) {
        *newX = x + dx[i];
        *newY = y + dy[i];

        if (*newX >= 0 && *newX < WIDTH && *newY >= 0 && *newY < HEIGHT && 
            isWalkable(*newX, *newY, &gameState) && !isSolid(*newX, *newY) && !isInHole(*newX, *newY)) {
            return 1;
        }
    }

    if (y - 1 >= 0 && isWalkable(x, y - 1, &gameState) && !isSolid(x, y - 1) && !isInHole(x, y - 1)) {
        *newX = x;
        *newY = y - 1;
        return 1;
    }

    return 0;
}

void updateHoleTimers(GameState *state) {
    os_t currentTime = os_read_monotonic_time();

    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            if (map[y][x] == '.' && dug[y][x]) {
                

                if (state->player.tileX == x && state->player.tileY == y) {
                    state->player.inHole = 1;
                }

                for (int i = 0; i < state->enemyCount; i++) {
                    Entity *enemy = &state->enemies[i];
                    if (enemy->tileX == x && enemy->tileY == y) {
                        enemy->inHole = 1;
                    }
                }

                if (holeTimer[y][x] != 0 && 
                    (currentTime - holeTimer[y][x]) >= HOLE_REGENERATION_TIME) {

                    if (state->player.inHole && state->player.tileX == x && state->player.tileY == y) {
                        int newX, newY;
                        if (findSafePosition(x, y, &newX, &newY)) {
                            state->player.visualX = newX;
                            state->player.visualY = newY;

                            state->player.targetX = newX;
                            state->player.targetY = newY;
                            updateLogicalPosition(&state->player);
                            state->player.inHole = 0;
                            state->player.isMoving = 1; 
                            state->player.moveDir = UP; 
                        } else {
                            holeTimer[y][x] = currentTime;
                            continue;
                        }
                    }

                    for (int i = 0; i < state->enemyCount; i++) {
                        Entity *enemy = &state->enemies[i];
                        if (enemy->inHole && enemy->tileX == x && enemy->tileY == y) {
                            int newX, newY;
                            if (findSafePosition(x, y, &newX, &newY)) {
                                enemy->visualX = newX;
                                enemy->visualY = newY;

                                enemy->targetX = newX;
                                enemy->targetY = newY;
                                updateLogicalPosition(enemy);
                                enemy->inHole = 0;
                                enemy->isMoving = 1; 
                                enemy->moveDir = UP; 
                            } else {
                                holeTimer[y][x] = currentTime;
                                continue;
                            }
                        }
                    }

                    map[y][x] = '#';
                    holeTimer[y][x] = 0;
                    dug[y][x] = 0;
                }
            }
        }
    }

    if (map[state->player.tileY][state->player.tileX] != '.' || 
        !dug[state->player.tileY][state->player.tileX]) {
        state->player.inHole = 0;
    }

    for (int i = 0; i < state->enemyCount; i++) {
        Entity *enemy = &state->enemies[i];
        if (map[enemy->tileY][enemy->tileX] != '.' || 
            !dug[enemy->tileY][enemy->tileX]) {
            enemy->inHole = 0;
        }
    }
}